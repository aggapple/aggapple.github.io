[{"content":"# Convert MD（MarkDown） to PDF in Atom 1. Atom에서 MD파일 미리보기 실행 Windows : Ctrl + Shift + M Mac : control + Shift + M 2. 미리보기창 우클릭 후 \u0026ldquo;Save As HTML..\u0026rdquo; 선택 4. 저장된 HTML을 Chrome에서 열기 5. Chrome 메뉴에서 \u0026ldquo;인쇄(P)\u0026ldquo;를 선택 후 인쇄미리보기창 표시 6. 인쇄 대상을 \u0026ldquo;PDF로 저장\u0026quot;으로 지정 후 저장 (옵션_1) 페이지 분할 필요 시 html style에 개행 tag 적용 페이지 분할 tag 정의 \u0026lt;style\u0026gt; .break { page-break-before: always; } \u0026lt;/style\u0026gt; 페이지 분할 tag 사용 \u0026lt;body\u0026gt; \u0026lt;p class=\u0026#34;break\u0026#34;/\u0026gt; \u0026lt;/body\u0026gt; (옵션_2) 링크이동 tag 적용 링크 위치 지정 \u0026lt;body\u0026gt; \u0026lt;a name=\u0026#34;Move to here!!\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; 링크 이동 호출 \u0026lt;body\u0026gt; \u0026lt;a href=\u0026#34;#Move to hear!!\u0026#34;\u0026gt;Click hear!!\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; ","permalink":"https://aggapple.github.io/post/tools/atomconvert-mdmarkdown-to-pdf/","summary":"# Convert MD（MarkDown） to PDF in Atom 1. Atom에서 MD파일 미리보기 실행 Windows : Ctrl + Shift + M Mac : control + Shift + M 2. 미리보기창 우클릭 후 \u0026ldquo;Save As HTML..\u0026rdquo; 선택 4. 저장된 HTML을 Chrome에서 열기 5. Chrome 메뉴에서 \u0026ldquo;인쇄(P)\u0026ldquo;를 선택 후 인쇄미리보기창 표시 6. 인쇄 대상을 \u0026ldquo;PDF로 저장\u0026quot;으로 지정 후 저장 (옵션_1) 페이지 분할 필요 시 html style에 개행 tag 적용 페이지 분할 tag 정의 \u0026lt;style\u0026gt; .","title":"［atom］Convert MD（MarkDown） to PDF"},{"content":"# Distributing contents to Github-pages with Hugo 1. Contents 생성 및 public에 반영하기 # contents 생성 \u0026gt; hugo new post/Demo-post.md # 생성된 contents를 public에 반영하기 \u0026gt; hugo -t PaperMod Contents 생성 후 draft: true 로 설정할 경우 hugo server -D 에서만 표시되므로 배포 시 삭제 또는 false로 변경 2. Contents 배포하기(수동) # public directory로 이동 \u0026gt; cd public # public 배포 \u0026gt; git add . \u0026gt; git commit -m \u0026#39;commit message\u0026#39; \u0026gt; git push origin domain # project root directory로 이동 \u0026gt; cd .. # project root 배포 \u0026gt; git add . \u0026gt; git commit -m \u0026#39;commit message\u0026#39; \u0026gt; git push origin master 3. 사이트에서 contents 반영 확인 사이트 반영까지 약 1분정도 소요 ","permalink":"https://aggapple.github.io/post/tools/hugohugo%EB%A1%9C-github-pages%EC%97%90-contents-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0/","summary":"# Distributing contents to Github-pages with Hugo 1. Contents 생성 및 public에 반영하기 # contents 생성 \u0026gt; hugo new post/Demo-post.md # 생성된 contents를 public에 반영하기 \u0026gt; hugo -t PaperMod Contents 생성 후 draft: true 로 설정할 경우 hugo server -D 에서만 표시되므로 배포 시 삭제 또는 false로 변경 2. Contents 배포하기(수동) # public directory로 이동 \u0026gt; cd public # public 배포 \u0026gt; git add . \u0026gt; git commit -m \u0026#39;commit message\u0026#39; \u0026gt; git push origin domain # project root directory로 이동 \u0026gt; cd .","title":"［hugo］Hugo로 Github Pages에 Contents 배포하기"},{"content":"# Play downloaded sound file in NotificationServiceExtension 1. 다운로드 저장경로 관련 이슈 앱에서 다운로드 파일을 .documentDirectory 경로에 저장 시 NotificationServiceExtension에서 접근되지 않음 Capabilities의 App Groups를 활용해 파일 접근이 가능하도록 설정\nApp Groups를 사용하더라도 Apple에서 지정한 음원 공유용 경로가 아니면 음원을 불러오지 못함 Answer by KevinE on Jul 30, 2019 5:11 PM\nThe specifics of how your app should work are going to vary a lot depending on your specific use cases and app design, but our general recommendation for push to talk apps is that you shift to using standard push notifications instead of PushKit for message delivery. More specifically, on the receiver side your Notification Service Extension should download the relevant audio and attach that sound to your particular message.\nTo support that approach, starting in iOS 13, the system looks for possible sound files in the apps group container(s) as well as the preexisting search locations. The documentation hasn\u0026rsquo;t been updated for this yet (), but there is header file documentation describing the details in the comments for \u0026ldquo;soundNamed:\u0026rdquo; in \u0026ldquo;UNNotificationSound.h\u0026rdquo;:\n// The sound file to be played for the notification. The sound must be in the Library/Sounds folder of the app\u0026rsquo;s data container or the Library/Sounds folder of an app group data container. If the file is not found in a container, the system will look in the app\u0026rsquo;s bundle.\nBreaking that down in detail, we look for sound files in the following order and locations:\nYour apps direct container in \u0026ldquo;Library/Sounds\u0026rdquo;. Your apps group(s) directory in a directory named \u0026ldquo;Library/Sounds\u0026rdquo; Your apps bundle The main things to keep in mind here:\nDirectory #2 is \u0026ldquo;Library/Sounds\u0026rdquo;, not just \u0026ldquo;Sounds\u0026rdquo;. You\u0026rsquo;ll need to create a \u0026ldquo;Library\u0026rdquo; directory with a \u0026ldquo;Sounds\u0026rdquo; directory inside it, not just a \u0026ldquo;Sounds\u0026rdquo; directory. The apps direct container is still the first place we\u0026rsquo;ll look, so you\u0026rsquo;ll need to be careful about how you name your files. I would recommend either using the group directory for all sounds or following a naming convention for the two different locations so that they never collide. Your Network Service Extension can\u0026rsquo;t see the contents of directory #1, so it can\u0026rsquo;t know whether or not a particular name will collide.\n출처 : https://stackoverflow.com/questions/48379757/ios-play-remote-audio-file-from-notification-extension\n2. Alamofire(AF)를 이용한 음원(wav) 다운로드 Alamofire(AF) v5.6.1 func soundFileDownloadRequest() { let url = \u0026#34;https://domain.com/path/sound.wav\u0026#34; let appGroupId = \u0026#34;group.app.id\u0026#34; // AppGroupId는 group. 으로 설정 let soundFolderPath = \u0026#34;/Library/Sounds/\u0026#34; // 폴더 경로 설정 필수 let fileName = URL(string: url)!.lastPathComponent let fileManager = FileManager.default if let filePathUrl = fileManager.containerURL(forSecurityApplicationGroupIdentifier: appGroupId)?.path .appending(soundFolderPath).appending(fileName) { var isDirectory: ObjCBool = false let isFileExist = fileManager.fileExists(atPath: filePathUrl, isDirectory: \u0026amp;isDirectory) if isFileExist { // 다운로드받은 파일이 존재합니다. } else { // 파일 다운로드 let destination: DownloadRequest.Destination = { _, _ in return (URL.init(fileURLWithPath: filePathUrl), [.removePreviousFile, .createIntermediateDirectories]) } AF.download(url, method: .get, to: destination).response { (response) in if (response.error == nil) { // 다운로드 성공 } else { // 다운로드 실패 } } } } } 3. NotificationServiceExtension에서 다운로드 받은 음원(wav) 재생 override func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: @escaping (UNNotificationContent) -\u0026gt; Void) { bestAttemptContent = (request.content.mutableCopy() as? UNMutableNotificationContent) // 이하 생략.. let appGroupId = \u0026#34;group.app.id\u0026#34; let soundFolderPath = \u0026#34;/Library/Sounds/\u0026#34; let fileName = \u0026#34;sound.wav\u0026#34; let fileManager = FileManager.default if let filePathUrl = fileManager.containerURL(forSecurityApplicationGroupIdentifier: appGroupId)?.path .appending(soundFolderPath).appending(fileName) { var isDirectory: ObjCBool = false let isFileExist = fileManager.fileExists(atPath: filePathUrl, isDirectory: \u0026amp;isDirectory) if isFileExist { // 다운로드 음원 재생 bestAttemptContent.sound = UNNotificationSound(named: UNNotificationSoundName(rawValue: fileName)) } else { // default 음원 재생 (default.wav가 있는 경우) bestAttemptContent.sound = UNNotificationSound(named: UNNotificationSoundName(rawValue: \u0026#34;default.wav\u0026#34;)) } } } ","permalink":"https://aggapple.github.io/post/ios/iosswiftnotificationserviceextension%EC%97%90%EC%84%9C-%EB%8B%A4%EC%9A%B4%EB%A1%9C%EB%93%9C-%EC%9D%8C%EC%9B%90-%EC%9E%AC%EC%83%9D%ED%95%98%EA%B8%B0/","summary":"# Play downloaded sound file in NotificationServiceExtension 1. 다운로드 저장경로 관련 이슈 앱에서 다운로드 파일을 .documentDirectory 경로에 저장 시 NotificationServiceExtension에서 접근되지 않음 Capabilities의 App Groups를 활용해 파일 접근이 가능하도록 설정\nApp Groups를 사용하더라도 Apple에서 지정한 음원 공유용 경로가 아니면 음원을 불러오지 못함 Answer by KevinE on Jul 30, 2019 5:11 PM\nThe specifics of how your app should work are going to vary a lot depending on your specific use cases and app design, but our general recommendation for push to talk apps is that you shift to using standard push notifications instead of PushKit for message delivery.","title":"［iOS／swift］NotificationServiceExtension에서 다운로드 음원 재생하기"},{"content":"Time waits for no one.\n","permalink":"https://aggapple.github.io/post/prologue/","summary":"Time waits for no one.","title":"Prologue"}]